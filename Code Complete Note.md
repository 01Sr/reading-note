[TOC]

# Code Complete

## Part 1: Laying the Foundation

### 第一章 软件构建入门

#### 1.1 什么是软件构建

**软件开发过程:**

- 定义问题(problem definition)
- 需求分析(requirements development)
- 规划构建(construction planning)
- 软件架构(software architecture), 或高层设计(high-level design)
- 详细设计(detailed design)
- 编码与调试(coding and debugging)
- 单元测试(unit testing)
- 集成测试(integration testing)
- 集成(integration)
- 系统测试(system testing)
- 保障维护(corrective maintenance)

**构建活动**主要关注编码与调试, 但也设计详细设计、规划构建、单元测试、集成和集成测试等其他活动.

#### 1.2 软件构建的重要性

- 构建活动是如软件开发的主要组成部分(时间上)
- 构建活动是软件开发中的核心活动(过程上)
- 把主要精力集中于构建活动, 可以大大提高程序员的生产率
- 构建活动的产物--源代码--往往是对软件的唯一精确描述(相对于容易过时或不详细的文档来说)
- 构建活动是唯一一项确保会完成的工作(相对于其他过程)



### 第二章 用隐喻来更好地理解软件开发

- 隐喻是把要了解的陌生的事物与熟悉的事物类比, 可以启发思维, 帮助我们更好理解软件开发;
- 隐喻有好坏之分;
- 跟造房子一样, 软件构建需要仔细准备, 大小型项目之间有差别;
- 因地制宜的使用不同的方式来编程, 而不是固守一个固定的方式;
- 可以通过多个隐喻来理解事物



### 第三章 前期准备

**WISCA综合症**: Why isn't Sam coding anything?

**WIMP综合症**: Why isn't Mary programming?

引入缺陷时间和找到缺陷时间表

|      |			| Time Detected |      |			 |			|
| :--: | :--: | :--: | :--: | :--: | :--: |
| 引入时间 | 需求 | 架构 | 构建 | 系统测试 | 发布后 |
| 需求 | 1 | 3 | 5-10 | 10 | 10-100 |
| 架构 | -- | 1 | 10 | 15 | 25-100 |
| 构建 | -- | -- | 1 | 10 | 10-25 |

引入缺陷时间、找到缺陷时间和解决缺陷费用表

![引用缺陷时间和解决缺陷费用表](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdptpuhhwyj30ro0f275z.jpg)

#### 3.2 Determine the Kind of Software You’re Working On

![image-20200411212055419](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdq56nc2g9j30w60lk0wh.jpg)

![image-20200411212139606](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdq57du7zoj30u011aq9z.jpg)

#### 3.5 架构的先决条件

##### Program Organization

- 需要对系统做一个概括性的综述;
- 记述放弃替代方案, 选择最终方案的原因;

- 定义程序的主要构造块;
- 明确定义各个构造块的责任, 每个构造块负责一个区域的事情, 并且对其他构造块负责的东西知道的越少越好;
- 明确构造块之间的通信规则. 明确一个构造块能够直接/简介使用和不能使用哪些构造块.

##### Major Classes

- 定义主要的类. 类的责任和与其他类的交互. 描述继承关系、 状态转换、对象持久化. 对于大型系统, 还要描述类是如何组织成子系统的.
- 记述放弃其他类设计方案,  选择当前方案的原因. **80/20法则**:对构成系统80%行为的20%的类进行详细说明;

##### Data Design

- 描述主要文件和数据表设计;
- 记述放弃其他方案,  选择当前方案的原因;
- 数据也要封装;
- 详细定义数据库的高层组织结构和内容, 解释单个/多个数据库的优劣(对于当前系统), 文件/数据库的优劣(对于当前系统), 描述访问统一数据的程序的交互方式, 说明会创建哪些数据视图;

##### Business Rules

如果架构依赖于特定的业务规则, 那么就要详细描述这些规则和对设计的影响.

##### User Interface Design

- UI应该在需求阶段进行详细说明. 如果没有就应该在架构中详细说明.
- 架构应该模块化, 以便替换新UI时不印象业务规则和程序输出

##### Resource Management

架构应该描述管理scarce(难得的, 稀罕的) resource的计划, scarce resource包括数据库连接、 线程、 句柄等.

##### Security

架构应该描述实现设计层面和代码层面安全性的方法.

##### Performance

如果需要关注性能, 就应该在需求中定义性能目标.架构需要定义性能指标

##### Scalability

架构需要描述如何应对用户/数据库记录/服务器等数据的增长, 如果可伸缩性不是问题, 也需要说明原因

##### Internaltionalization/Localization(I18n/L10n)

估算字符串资源.考虑字符串/字符集问题.字符串资源的调用方式

##### Input/Output

定义读取策略: ==look-ahead、look-behind和just-in-time==, 描述IO错误检测所在层次.

##### Error Processing

- 纠正/检测;
- 主动/被动;
- 错误传播;
- 处理约定;
- 何时抛出异常, 何地捕获异常, 如何记录异常, 如何描述异常
- 在什么层次上处理错误
- 类验证输入数据有效性的责任
- 环境内建的错误处理机制/自己制定

##### Fault Tolerance

架构应该详细定义期望的容错种类

##### Architectural Feasibility(可行性)

考量性能目标、资源限制、实现环境

##### Overengineering(过度工程)

在软件中, 链条的强度不是取决于最薄弱的一环, 而是等于所有薄弱环节的乘积(因为错误可能被传播并放大). 所以架构要清楚指出应该Overengineering,还是简单处理.

##### Buy-vs-Build Decisions

架构应该说明采用自造组件/采用现有组件的原因

##### Reuse Decisions

描述复用组件如何处理

##### Change Strategy

- 描述变更策略, 列举可能变更的功能.
- 描述delay commitment策略, 一个例子是配置优于编码

##### General Architectural Quality

- 架构应该是完整的概念体系, 只带有少许其他精炼信息;
- 架构的目标要清晰;
- 架构应该描述主要决策的动机;
- 优秀的架构很大程度上与机器和编程语言无关
- 架构要保持在“underspecifying”和“overspecifying”之间
- 架构要指出有风险的地方
- 架构要多视角;
- 架构不应该包括架构者本身都不懂的东西

#### 3.6 前期准备的时间长度

- 不稳定的需求, 需要额外预留时间来分析定义, 来降低不稳定性对构建的影响;

- 先需求分析, 再估计完成项目的时间;
- 对于不熟悉的软件架构, 要为不确定性预留时间



### 第四章 关键构建的决策

#### 4.1 选择编程语言

> 一套好的符号系统能把大脑从所有非必要的工作中解脱出来, 集中精力去对付更高级的问题.

#### 4.2 编程约定

实现必须在内部保持一致性, 并与指导它的架构保持一致性. 例如编程风格的一致性.

#### 4.3 你在技术浪潮中的位置

- 在技术浪潮中的不同位置中, 需要做不同的计划. 

- 程序员的“工作环境”是不同的, 在初级的环境下, 本书的编程实践更有帮助. 但是编程工具不应该决定你的编程思路.

**在一种语言上编程**: 程序员的思想限制于语言的直接支持

**深入一种语言去编程**: 程序员先决定表达什么, 然后再决定如何使用特定语言提供的工具来表达他们的思想.

**大多数重要的编程原则并不依赖特定的语言, 而依赖于你使用语言的方式.如果你使用的语言缺乏你需要的功能, 或者潜伏着其他问题, 那就应该试着去弥补它.发明自己的编码约定、标准、类库以及其他改进措施.**

#### 4.4 选择主要的构建实践

构建实践体现在四个方面:编码、团队工作、质量保证和工具

#### 要点:

- 明确语言的优缺点;
- 编程前做好约定;
- 选择适合的构建实践;
- 深入一种语言编程;
- 明确在技术浪潮中的位置, 并相应的调整计划和预期目标;